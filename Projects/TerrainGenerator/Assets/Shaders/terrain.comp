#version 460

#include "Noise/perlin.glsl"
#include "Noise/voronoi.glsl"

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

uniform float uChunkLength;
uniform float uChunkHeight;
uniform float uChunkHeightStep;
uniform uint uMaxChunkDivisions;
uniform ivec2 uChunkOffset;

layout(rgba32ui) uniform uimage2D uChunkTexture;

// Color helper functions

uint mapColor1(float colorNoise, bool firstTriangle, uint[2] colors) {
    int idx = int(floor(colorNoise * 1));
    idx = idx * 2 + int(firstTriangle);
    return colors[idx];
}

uint mapColor2(float colorNoise, bool firstTriangle, uint[4] colors) {
    int idx = int(floor(colorNoise * 2));
    idx = idx * 2 + int(firstTriangle);
    return colors[idx];
}

uint mapColor3(float colorNoise, bool firstTriangle, uint[6] colors) {
    int idx = int(floor(colorNoise * 3));
    idx = idx * 2 + int(firstTriangle);
    return colors[idx];
}

// Main functions

float getHeightNoise(vec2 uv)
{
    vec2 ignore; // For the voronoi closest centers

    const int seed = 167856433;
    uv = uChunkOffset + uv;
    
    float freq1 = 0.5;
    float noise1 = voronoiNoise(seed, uv * freq1, VORONOI_DISTANCE_EUCLIDEAN_SQR, VORONOI_RETURN_DISTANCE, ignore);
    noise1 = noise1 * 0.5 + 0.5;
    noise1 = pow(noise1, 2);
    float factor1 = 100;

    float freq2 = 1;
    float noise2 = perlinNoise(seed, uv * freq2);
    noise2 = noise2 * 0.5 + 0.5;
    float factor2 = 1;

    float noise = (noise1 * factor1 +  noise2 * factor2) / (factor1 + factor2);
    
    float normalizedStep = uChunkHeightStep / uChunkHeight;
    normalizedStep /= float(gl_NumWorkGroups.x) / uMaxChunkDivisions;
    return clamp(round(noise / normalizedStep) * normalizedStep, 0, 1);
}

uint getColor(vec2 uv, float hightNoise, bool firstTriangle)
{
    vec2 ignore; // For the voronoi closest centers

    const int seedHight = 75984732;
    const int seedColor = 89361823;
    uv = uChunkOffset + uv;

    hightNoise *= 4;

    float freqH = 10;
    hightNoise += voronoiNoise(seedHight, uv * freqH, VORONOI_DISTANCE_EUCLIDEAN_SQR, VORONOI_RETURN_CELL_VALUE, ignore) * 0.1;

    float freqC = 5;
    float colorNoise = voronoiNoise(seedColor, uv * freqC, VORONOI_DISTANCE_EUCLIDEAN_SQR, VORONOI_RETURN_CELL_VALUE, ignore) * 0.5 + 0.5;

    if (hightNoise < 0.2) // Grass
    {
        const uint[] colors = { 0x22AE58, 0x31DE40, 0x22AE58, 0x3EFF46, 0x1A9F50, 0x31DE40 };
        return mapColor3(colorNoise, firstTriangle, colors);
    }
    if (hightNoise < 0.8) // Dirt
    {
        const uint[] colors = { 0x5F4138, 0x704D42, 0x51342E, 0x5F4138, 0x402722, 0x51342E };
        return mapColor3(colorNoise, firstTriangle, colors);
    }
    else // Snow
    {
        const uint[] colors = { 0xF9F9F9, 0xDFDFDF };
        return mapColor1(colorNoise, firstTriangle, colors);
    }
}

void main()
{
    float divisionSize =  1 / (gl_NumWorkGroups.x - 1.0);
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);

    // Height
    vec2 uvHeight = vec2(gl_GlobalInvocationID.xy) * divisionSize;
    float height = getHeightNoise(uvHeight);
    uint heightUint = uint(height * 4294967295.0);

    // Full triangle hights (for color calculation)
    vec2 uvHeight1 = vec2(gl_GlobalInvocationID.xy + vec2(1, 0)) * divisionSize;
    float height1 = getHeightNoise(uvHeight1);

    vec2 uvHeight2 = vec2(gl_GlobalInvocationID.xy + vec2(0, 1)) * divisionSize;
    float height2 = getHeightNoise(uvHeight2);

    vec2 uvHeight3 = vec2(gl_GlobalInvocationID.xy + vec2(1, 1)) * divisionSize;
    float height3 = getHeightNoise(uvHeight3);

    // Color
    vec2 uvColor0 = (gl_GlobalInvocationID.xy + vec2(0.33333333)) * divisionSize;
    float heightColor0 = (height + height1 + height2) / 3;
    uint color0 = getColor(uvColor0, heightColor0, true);

    vec2 uvColor1 = (gl_GlobalInvocationID.xy + vec2(0.66666667)) * divisionSize;
    float heightColor1 = (height1 + height2 + height3) / 3;
    uint color1 = getColor(uvColor1, heightColor1, false);
    
    // Save to texture
    imageStore(uChunkTexture, pixel, uvec4(heightUint, color0, color1, 0));
}